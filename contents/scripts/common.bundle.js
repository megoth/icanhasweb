(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["common"],{

/***/ "../node_modules/blissfuljs/bliss.js":
/*!*******************************************!*\
  !*** ../node_modules/blissfuljs/bliss.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() {\n\"use strict\";\n\nfunction overload(callback, start, end) {\n\tstart = start === undefined ? 1 : start;\n\tend = end || start + 1;\n\n\tif (end - start <= 1) {\n\t\treturn function() {\n\t\t\tif (arguments.length <= start || $.type(arguments[start]) === \"string\") {\n\t\t\t\treturn callback.apply(this, arguments);\n\t\t\t}\n\n\t\t\tvar obj = arguments[start];\n\t\t\tvar ret;\n\n\t\t\tfor (var key in obj) {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\targs.splice(start, 1, key, obj[key]);\n\t\t\t\tret = callback.apply(this, args);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t};\n\t}\n\n\treturn overload(overload(callback, start + 1, end), start, end - 1);\n}\n\n// Copy properties from one object to another. Overwrites allowed.\n// Subtle difference of array vs string whitelist: If property doesn't exist in from, array will not define it.\nfunction extend(to, from, whitelist) {\n\tvar whitelistType = type(whitelist);\n\n\tif (whitelistType === \"string\") {\n\t\t// To copy gettters/setters, preserve flags etc\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(from, whitelist);\n\n\t\tif (descriptor && (!descriptor.writable || !descriptor.configurable || !descriptor.enumerable || descriptor.get || descriptor.set)) {\n\t\t\tdelete to[whitelist];\n\t\t\tObject.defineProperty(to, whitelist, descriptor);\n\t\t}\n\t\telse {\n\t\t\tto[whitelist] = from[whitelist];\n\t\t}\n\t}\n\telse if (whitelistType === \"array\") {\n\t\twhitelist.forEach(function(property) {\n\t\t\tif (property in from) {\n\t\t\t\textend(to, from, property);\n\t\t\t}\n\t\t});\n\t}\n\telse {\n\t\tfor (var property in from) {\n\t\t\tif (whitelist) {\n\t\t\t\tif (whitelistType === \"regexp\" && !whitelist.test(property) ||\n\t\t\t\t\twhitelistType === \"function\" && !whitelist.call(from, property)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textend(to, from, property);\n\t\t}\n\t}\n\n\treturn to;\n}\n\n/**\n * Returns the [[Class]] of an object in lowercase (eg. array, date, regexp, string etc)\n */\nfunction type(obj) {\n\tif (obj === null) {\n\t\treturn \"null\";\n\t}\n\n\tif (obj === undefined) {\n\t\treturn \"undefined\";\n\t}\n\n\tvar ret = (Object.prototype.toString.call(obj).match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n\n\tif (ret == \"number\" && isNaN(obj)) {\n\t\treturn \"nan\";\n\t}\n\n\treturn ret;\n}\n\nvar $ = self.Bliss = extend(function(expr, context) {\n\tif (arguments.length == 2 && !context || !expr) {\n\t\treturn null;\n\t}\n\n\treturn $.type(expr) === \"string\"? (context || document).querySelector(expr) : expr || null;\n}, self.Bliss);\n\nextend($, {\n\textend: extend,\n\toverload: overload,\n\ttype: type,\n\n\tproperty: $.property || \"_\",\n\tlisteners: self.WeakMap? new WeakMap() : new Map(),\n\n\toriginal: {\n\t\taddEventListener: (self.EventTarget || Node).prototype.addEventListener,\n\t\tremoveEventListener: (self.EventTarget || Node).prototype.removeEventListener\n\t},\n\n\tsources: {},\n\n\tnoop: function() {},\n\n\t$: function(expr, context) {\n\t\tif (expr instanceof Node || expr instanceof Window) {\n\t\t\treturn [expr];\n\t\t}\n\n\t\tif (arguments.length == 2 && !context) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn Array.prototype.slice.call(typeof expr == \"string\"? (context || document).querySelectorAll(expr) : expr || []);\n\t},\n\n\t/*\n\t * Return first non-undefined value. Mainly used internally.\n\t */\n\tdefined: function () {\n\t\tfor (var i=0; i<arguments.length; i++) {\n\t\t\tif (arguments[i] !== undefined) {\n\t\t\t\treturn arguments[i];\n\t\t\t}\n\t\t}\n\t},\n\n\tcreate: function (tag, o) {\n\t\tif (tag instanceof Node) {\n\t\t\treturn $.set(tag, o);\n\t\t}\n\n\t\t// 4 signatures: (tag, o), (tag), (o), ()\n\t\tif (arguments.length === 1) {\n\t\t\tif ($.type(tag) === \"string\") {\n\t\t\t\to = {};\n\t\t\t}\n\t\t\telse {\n\t\t\t\to = tag;\n\t\t\t\ttag = o.tag;\n\t\t\t\to = $.extend({}, o, function(property) {\n\t\t\t\t\treturn property !== \"tag\";\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn $.set(document.createElement(tag || \"div\"), o);\n\t},\n\n\teach: function(obj, callback, ret) {\n\t\tret = ret || {};\n\n\t\tfor (var property in obj) {\n\t\t\tret[property] = callback.call(obj, property, obj[property]);\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tready: function(context, callback, isVoid) {\n\t\tif (typeof context === \"function\" && !callback) {\n\t\t\tcallback = context;\n\t\t\tcontext = undefined;\n\t\t}\n\n\t\tcontext = context || document;\n\n\t\tif (callback) {\n\t\t\tif (context.readyState !== \"loading\") {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$.once(context, \"DOMContentLoaded\", function() {\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (!isVoid) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t$.ready(context, resolve, true);\n\t\t\t});\n\t\t}\n\t},\n\n\t// Helper for defining OOP-like “classes”\n\tClass: function(o) {\n\t\tvar special = [\"constructor\", \"extends\", \"abstract\", \"static\"].concat(Object.keys($.classProps));\n\t\tvar init = o.hasOwnProperty(\"constructor\")? o.constructor : $.noop;\n\t\tvar Class;\n\n\t\tif (arguments.length == 2) {\n\t\t\t// Existing class provided\n\t\t\tClass = arguments[0];\n\t\t\to = arguments[1];\n\t\t}\n\t\telse {\n\t\t\tClass = function() {\n\t\t\t\tif (this.constructor.__abstract && this.constructor === Class) {\n\t\t\t\t\tthrow new Error(\"Abstract classes cannot be directly instantiated.\");\n\t\t\t\t}\n\n\t\t\t\tClass.super && Class.super.apply(this, arguments);\n\n\t\t\t\tinit.apply(this, arguments);\n\t\t\t};\n\n\t\t\tClass.super = o.extends || null;\n\n\t\t\tClass.prototype = $.extend(Object.create(Class.super? Class.super.prototype : Object), {\n\t\t\t\tconstructor: Class\n\t\t\t});\n\n\t\t\t// For easier calling of super methods\n\t\t\t// This doesn't save us from having to use .call(this) though\n\t\t\tClass.prototype.super = Class.super? Class.super.prototype : null;\n\n\t\t\tClass.__abstract = !!o.abstract;\n\t\t}\n\n\t\tvar specialFilter = function(property) {\n\t\t\treturn this.hasOwnProperty(property) && special.indexOf(property) === -1;\n\t\t};\n\n\t\t// Static methods\n\t\tif (o.static) {\n\t\t\t$.extend(Class, o.static, specialFilter);\n\n\t\t\tfor (var property in $.classProps) {\n\t\t\t\tif (property in o.static) {\n\t\t\t\t\t$.classProps[property](Class, o.static[property]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Instance methods\n\t\t$.extend(Class.prototype, o, specialFilter);\n\n\t\tfor (var property in $.classProps) {\n\t\t\tif (property in o) {\n\t\t\t\t$.classProps[property](Class.prototype, o[property]);\n\t\t\t}\n\t\t}\n\n\t\treturn Class;\n\t},\n\n\t// Properties with special handling in classes\n\tclassProps: {\n\t\t// Lazily evaluated properties\n\t\tlazy: overload(function(obj, property, getter) {\n\t\t\tObject.defineProperty(obj, property, {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar value = getter.call(this);\n\n\t\t\t\t\tObject.defineProperty(this, property, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t});\n\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\t// Blind write: skip running the getter\n\t\t\t\t\tObject.defineProperty(this, property, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t\treturn obj;\n\t\t}),\n\n\t\t// Properties that behave like normal properties but also execute code upon getting/setting\n\t\tlive: overload(function(obj, property, descriptor) {\n\t\t\tif ($.type(descriptor) === \"function\") {\n\t\t\t\tdescriptor = {set: descriptor};\n\t\t\t}\n\n\t\t\tObject.defineProperty(obj, property, {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar value = this[\"_\" + property];\n\t\t\t\t\tvar ret = descriptor.get && descriptor.get.call(this, value);\n\t\t\t\t\treturn ret !== undefined? ret : value;\n\t\t\t\t},\n\t\t\t\tset: function(v) {\n\t\t\t\t\tvar value = this[\"_\" + property];\n\t\t\t\t\tvar ret = descriptor.set && descriptor.set.call(this, v, value);\n\t\t\t\t\tthis[\"_\" + property] = ret !== undefined? ret : v;\n\t\t\t\t},\n\t\t\t\tconfigurable: descriptor.configurable,\n\t\t\t\tenumerable: descriptor.enumerable\n\t\t\t});\n\n\t\t\treturn obj;\n\t\t})\n\n\t},\n\n\t// Includes a script, returns a promise\n\tinclude: function() {\n\t\tvar url = arguments[arguments.length - 1];\n\t\tvar loaded = arguments.length === 2? arguments[0] : false;\n\n\t\tvar script = document.createElement(\"script\");\n\n\t\treturn loaded? Promise.resolve() : new Promise(function(resolve, reject) {\n\t\t\t$.set(script, {\n\t\t\t\tasync: true,\n\t\t\t\tonload: function() {\n\t\t\t\t\tresolve(script);\n\t\t\t\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\t\t\t},\n\t\t\t\tonerror: function() {\n\t\t\t\t\treject(script);\n\t\t\t\t},\n\t\t\t\tsrc: url,\n\t\t\t\tinside: document.head\n\t\t\t});\n\t\t});\n\t},\n\n\t// Dynamically load a CSS or JS resource\n\tload: function load(url, base) {\n\t\tbase = base? new URL(base, location.href) : location.href;\n\t\turl = new URL(url, base);\n\n\t\t// Prevent double loading\n\t\tvar loading = load.loading = load.loading || {};\n\n\t\tif (loading[url + \"\"]) {\n\t\t\treturn loading[url + \"\"];\n\t\t}\n\n\t\tif (/\\.css$/.test(url.pathname)) {\n\t\t\t// CSS file\n\t\t\treturn loading[url + \"\"] = new Promise(function(resolve, reject) {\n\t\t\t\tvar link = $.create(\"link\", {\n\t\t\t\t\t\"href\": url,\n\t\t\t\t\t\"rel\": \"stylesheet\",\n\t\t\t\t\t\"inside\": document.head,\n\t\t\t\t\tonload: function() {\n\t\t\t\t\t\tresolve(link);\n\t\t\t\t\t},\n\t\t\t\t\tonerror: function() {\n\t\t\t\t\t\treject(link);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// JS file\n\t\treturn loading[url + \"\"] = $.include(url);\n\t},\n\n\t/*\n\t * Fetch API inspired XHR wrapper. Returns promise.\n\t */\n\tfetch: function(url, o) {\n\t\tif (!url) {\n\t\t\tthrow new TypeError(\"URL parameter is mandatory and cannot be \" + url);\n\t\t}\n\n\t\t// Set defaults & fixup arguments\n\t\tvar env = extend({\n\t\t\turl: new URL(url, location),\n\t\t\tdata: \"\",\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {},\n\t\t\txhr: new XMLHttpRequest()\n\t\t}, o);\n\n\t\tenv.method = env.method.toUpperCase();\n\n\t\t$.hooks.run(\"fetch-args\", env);\n\n\t\t// Start sending the request\n\n\t\tif (env.method === \"GET\" && env.data) {\n\t\t\tenv.url.search += env.data;\n\t\t}\n\n\t\tdocument.body.setAttribute(\"data-loading\", env.url);\n\n\t\tenv.xhr.open(env.method, env.url.href, env.async !== false, env.user, env.password);\n\n\t\tfor (var property in o) {\n\t\t\tif (property === \"upload\") {\n\t\t\t\tif (env.xhr.upload && typeof o[property] === \"object\") {\n\t\t\t\t\t$.extend(env.xhr.upload, o[property]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (property in env.xhr) {\n\t\t\t\ttry {\n\t\t\t\t\tenv.xhr[property] = o[property];\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tself.console && console.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar headerKeys = Object.keys(env.headers).map(function(key) {\n\t\t\treturn key.toLowerCase();\n\t\t});\n\n\t\tif (env.method !== \"GET\" && headerKeys.indexOf(\"content-type\") === -1) {\n\t\t\tenv.xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n\t\t}\n\n\t\tfor (var header in env.headers) {\n\t\t\tif (env.headers[header] !== undefined) {\n\t\t\t\tenv.xhr.setRequestHeader(header, env.headers[header]);\n\t\t\t}\n\t\t}\n\n\t\tvar promise = new Promise(function(resolve, reject) {\n\t\t\tenv.xhr.onload = function() {\n\t\t\t\tdocument.body.removeAttribute(\"data-loading\");\n\n\t\t\t\tif (env.xhr.status === 0 || env.xhr.status >= 200 && env.xhr.status < 300 || env.xhr.status === 304) {\n\t\t\t\t\t// Success!\n\t\t\t\t\tresolve(env.xhr);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treject($.extend(Error(env.xhr.statusText), {\n\t\t\t\t\t\txhr: env.xhr,\n\t\t\t\t\t\tget status() {\n\t\t\t\t\t\t\treturn this.xhr.status;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tenv.xhr.onerror = function() {\n\t\t\t\tdocument.body.removeAttribute(\"data-loading\");\n\t\t\t\treject($.extend(Error(\"Network Error\"), {xhr: env.xhr}));\n\t\t\t};\n\n\t\t\tenv.xhr.ontimeout = function() {\n\t\t\t\tdocument.body.removeAttribute(\"data-loading\");\n\t\t\t\treject($.extend(Error(\"Network Timeout\"), {xhr: env.xhr}));\n\t\t\t};\n\n\t\t\tenv.xhr.send(env.method === \"GET\"? null : env.data);\n\t\t});\n\t\t// Hack: Expose xhr.abort(), by attaching xhr to the promise.\n\t\tpromise.xhr = env.xhr;\n\t\treturn promise;\n\t},\n\n\tvalue: function(obj) {\n\t\tvar hasRoot = typeof obj !== \"string\";\n\n\t\treturn $.$(arguments).slice(+hasRoot).reduce(function(obj, property) {\n\t\t\treturn obj && obj[property];\n\t\t}, hasRoot? obj : self);\n\t}\n});\n\n$.Hooks = new $.Class({\n\tadd: function (name, callback, first) {\n\t\tif (typeof arguments[0] != \"string\") {\n\t\t\t// Multiple hooks\n\t\t\tfor (var name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t(Array.isArray(name)? name : [name]).forEach(function(name) {\n\t\t\tthis[name] = this[name] || [];\n\n\t\t\tif (callback) {\n\t\t\t\tthis[name][first? \"unshift\" : \"push\"](callback);\n\t\t\t}\n\t\t}, this);\n\t},\n\n\trun: function (name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function(callback) {\n\t\t\tcallback.call(env && env.context? env.context : env, env);\n\t\t});\n\t}\n});\n\n$.hooks = new $.Hooks();\n\nvar _ = $.property;\n\n$.Element = function (subject) {\n\tthis.subject = subject;\n\n\t// Author-defined element-related data\n\tthis.data = {};\n\n\t// Internal Bliss element-related data\n\tthis.bliss = {};\n};\n\n$.Element.prototype = {\n\tset: overload(function(property, value) {\n\t\tif (property in $.setProps) {\n\t\t\t$.setProps[property].call(this, value);\n\t\t}\n\t\telse if (property in this) {\n\t\t\tthis[property] = value;\n\t\t}\n\t\telse {\n\t\t\tthis.setAttribute(property, value);\n\t\t}\n\n\t}, 0),\n\n\t// Run a CSS transition, return promise\n\ttransition: function(props, duration) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tif (\"transition\" in this.style && duration !== 0) {\n\t\t\t\t// Get existing style\n\t\t\t\tvar previous = $.extend({}, this.style, /^transition(Duration|Property)$/);\n\n\t\t\t\t$.style(this, {\n\t\t\t\t\ttransitionDuration: (duration || 400) + \"ms\",\n\t\t\t\t\ttransitionProperty: Object.keys(props).join(\", \")\n\t\t\t\t});\n\n\t\t\t\t$.once(this, \"transitionend\", function() {\n\t\t\t\t\tclearTimeout(i);\n\t\t\t\t\t$.style(this, previous);\n\t\t\t\t\tresolve(this);\n\t\t\t\t});\n\n\t\t\t\t// Failsafe, in case transitionend doesn’t fire\n\t\t\t\tvar i = setTimeout(resolve, duration+50, this);\n\n\t\t\t\t$.style(this, props);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$.style(this, props);\n\t\t\t\tresolve(this);\n\t\t\t}\n\t\t}.bind(this));\n\t},\n\n\t// Fire a synthesized event on the element\n\tfire: function (type, properties) {\n\t\tvar evt = document.createEvent(\"HTMLEvents\");\n\n\t\tevt.initEvent(type, true, true );\n\n\t\t// Return the result of dispatching the event, so we\n\t\t// can know if `e.preventDefault` was called inside it\n\t\treturn this.dispatchEvent($.extend(evt, properties));\n\t},\n\n\tbind: overload(function(types, options) {\n\t\tif (arguments.length > 1 && ($.type(options) === \"function\" || options.handleEvent)) {\n\t\t\t// options is actually callback\n\t\t\tvar callback = options;\n\t\t\toptions = $.type(arguments[2]) === \"object\"? arguments[2] : {\n\t\t\t\tcapture: !!arguments[2] // in case it's passed as a boolean 3rd arg\n\t\t\t};\n\t\t\toptions.callback = callback;\n\t\t}\n\n\t\tvar listeners = $.listeners.get(this) || {};\n\n\t\ttypes.trim().split(/\\s+/).forEach(function (type) {\n\t\t\tif (type.indexOf(\".\") > -1) {\n\t\t\t\ttype = type.split(\".\");\n\t\t\t\tvar className = type[1];\n\t\t\t\ttype = type[0];\n\t\t\t}\n\n\t\t\tlisteners[type] = listeners[type] || [];\n\n\t\t\tif (listeners[type].filter(function(l) {\n\t\t\t\treturn l.callback === options.callback && l.capture == options.capture;\n\t\t\t}).length === 0) {\n\t\t\t\tlisteners[type].push($.extend({className: className}, options));\n\t\t\t}\n\n\t\t\t$.original.addEventListener.call(this, type, options.callback, options);\n\t\t}, this);\n\n\t\t$.listeners.set(this, listeners);\n\t}, 0),\n\n\tunbind: overload(function(types, options) {\n\t\tif (options && ($.type(options) === \"function\" || options.handleEvent)) {\n\t\t\tvar callback = options;\n\t\t\toptions = arguments[2];\n\t\t}\n\n\t\tif ($.type(options) == \"boolean\") {\n\t\t\toptions = {capture: options};\n\t\t}\n\n\t\toptions = options || {};\n\t\toptions.callback = options.callback || callback;\n\n\t\tvar listeners = $.listeners.get(this);\n\n\t\t(types || \"\").trim().split(/\\s+/).forEach(function (type) {\n\t\t\tif (type.indexOf(\".\") > -1) {\n\t\t\t\ttype = type.split(\".\");\n\t\t\t\tvar className = type[1];\n\t\t\t\ttype = type[0];\n\t\t\t}\n\n\t\t\t//if listeners exist, always go through listeners to clean up\n\t\t\tif (!listeners) {\n\t\t\t\tif (type && options.callback) {\n\t\t\t\t\treturn $.original.removeEventListener.call(this, type, options.callback, options.capture);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mass unbinding, need to go through listeners\n\t\t\tfor (var ltype in listeners) {\n\t\t\t\tif (!type || ltype === type) {\n\t\t\t\t\t// No forEach, because we’re mutating the array\n\t\t\t\t\tfor (var i=0, l; l=listeners[ltype][i]; i++) {\n\t\t\t\t\t\tif ((!className || className === l.className)\n\t\t\t\t\t\t\t&& (!options.callback || options.callback === l.callback)\n\t\t\t\t\t\t\t&& (!!options.capture == !!l.capture || \n\t\t\t\t\t\t    \t\t!type && !options.callback && undefined === options.capture)\n\t\t\t\t\t\t   ) {\n\t\t\t\t\t\t\t\tlisteners[ltype].splice(i, 1);\n\t\t\t\t\t\t\t\t$.original.removeEventListener.call(this, ltype, l.callback, l.capture);\n\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t}, 0),\n\n\t// Return a promise that resolves when an event fires, then unbind\n\twhen: function(type, test) {\n\t\tvar me = this;\n\t\treturn new Promise(function(resolve) {\n\t\t\tme.addEventListener(type, function callee(evt) {\n\t\t\t\tif (!test || test.call(this, evt)) {\n\t\t\t\t\tthis.removeEventListener(type, callee);\n\t\t\t\t\tresolve(evt);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\ttoggleAttribute: function(name, value, test) {\n\t\tif (arguments.length < 3) {\n\t\t\ttest = value !== null;\n\t\t}\n\n\t\tif (test) {\n\t\t\tthis.setAttribute(name, value);\n\t\t}\n\t\telse {\n\t\t\tthis.removeAttribute(name);\n\t\t}\n\t}\n};\n\n/*\n * Properties with custom handling in $.set()\n * Also available as functions directly on element._ and on $\n */\n$.setProps = {\n\t// Set a bunch of inline CSS styles\n\tstyle: function (val) {\n\t\tfor (var property in val) {\n\t\t\tif (property in this.style) {\n\t\t\t\t// camelCase versions\n\t\t\t\tthis.style[property] = val[property];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// This way we can set CSS Variables too and use normal property names\n\t\t\t\tthis.style.setProperty(property, val[property]);\n\t\t\t}\n\t\t}\n\t},\n\n\t// Set a bunch of attributes\n\tattributes: function (o) {\n\t\tfor (var attribute in o) {\n\t\t\tthis.setAttribute(attribute, o[attribute]);\n\t\t}\n\t},\n\n\t// Set a bunch of properties on the element\n\tproperties: function (val) {\n\t\t$.extend(this, val);\n\t},\n\n\t// Bind one or more events to the element\n\tevents: function (val) {\n\t\tif (arguments.length == 1 && val && val.addEventListener) {\n\t\t\t// Copy events from other element (requires Bliss Full)\n\t\t\tvar me = this;\n\n\t\t\t// Copy listeners\n\t\t\tif ($.listeners) {\n\t\t\t\tvar listeners = $.listeners.get(val);\n\n\t\t\t\tfor (var type in listeners) {\n\t\t\t\t\tlisteners[type].forEach(function(l) {\n\t\t\t\t\t\t$.bind(me, type, l.callback, l.capture);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy inline events\n\t\t\tfor (var onevent in val) {\n\t\t\t\tif (onevent.indexOf(\"on\") === 0) {\n\t\t\t\t\tthis[onevent] = val[onevent];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn $.bind.apply(this, [this].concat($.$(arguments)));\n\t\t}\n\t},\n\n\tonce: overload(function(types, callback) {\n\t\tvar me = this;\n\t\tvar once = function() {\n\t\t\t$.unbind(me, types, once);\n\n\t\t\treturn callback.apply(me, arguments);\n\t\t};\n\n\t\t$.bind(this, types, once, {once: true});\n\t}, 0),\n\n\t// Event delegation\n\tdelegate: overload(function (type, selector, callback) {\n\t\t$.bind(this, type, function(evt) {\n\t\t\tif (evt.target.closest(selector)) {\n\t\t\t\tcallback.call(this, evt);\n\t\t\t}\n\t\t});\n\t}, 0, 2),\n\n\t// Set the contents as a string, an element, an object to create an element or an array of these\n\tcontents: function (val) {\n\t\tif (val || val === 0) {\n\t\t\t(Array.isArray(val)? val : [val]).forEach(function (child) {\n\t\t\t\tvar type = $.type(child);\n\n\t\t\t\tif (/^(string|number)$/.test(type)) {\n\t\t\t\t\tchild = document.createTextNode(child + \"\");\n\t\t\t\t}\n\t\t\t\telse if (type === \"object\") {\n\t\t\t\t\tchild = $.create(child);\n\t\t\t\t}\n\n\t\t\t\tif (child instanceof Node) {\n\t\t\t\t\tthis.appendChild(child);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t},\n\n\t// Append the element inside another element\n\tinside: function (element) {\n\t\telement && element.appendChild(this);\n\t},\n\n\t// Insert the element before another element\n\tbefore: function (element) {\n\t\telement && element.parentNode.insertBefore(this, element);\n\t},\n\n\t// Insert the element after another element\n\tafter: function (element) {\n\t\telement && element.parentNode.insertBefore(this, element.nextSibling);\n\t},\n\n\t// Insert the element before another element's contents\n\tstart: function (element) {\n\t\telement && element.insertBefore(this, element.firstChild);\n\t},\n\n\t// Wrap the element around another element\n\taround: function (element) {\n\t\tif (element && element.parentNode) {\n\t\t\t$.before(this, element);\n\t\t}\n\n\t\tthis.appendChild(element);\n\t}\n};\n\n$.Array = function (subject) {\n\tthis.subject = subject;\n};\n\n$.Array.prototype = {\n\tall: function(method) {\n\t\tvar args = $.$(arguments).slice(1);\n\n\t\treturn this[method].apply(this, args);\n\t}\n};\n\n// Extends Bliss with more methods\n$.add = overload(function(method, callback, on, noOverwrite) {\n\ton = $.extend({$: true, element: true, array: true}, on);\n\n\tif ($.type(callback) == \"function\") {\n\t\tif (on.element && (!(method in $.Element.prototype) || !noOverwrite)) {\n\t\t\t$.Element.prototype[method] = function () {\n\t\t\t\treturn this.subject && $.defined(callback.apply(this.subject, arguments), this.subject);\n\t\t\t};\n\t\t}\n\n\t\tif (on.array && (!(method in $.Array.prototype) || !noOverwrite)) {\n\t\t\t$.Array.prototype[method] = function() {\n\t\t\t\tvar args = arguments;\n\t\t\t\treturn this.subject.map(function(element) {\n\t\t\t\t\treturn element && $.defined(callback.apply(element, args), element);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\n\t\tif (on.$) {\n\t\t\t$.sources[method] = $[method] = callback;\n\n\t\t\tif (on.array || on.element) {\n\t\t\t\t$[method] = function () {\n\t\t\t\t\tvar args = [].slice.apply(arguments);\n\t\t\t\t\tvar subject = args.shift();\n\t\t\t\t\tvar Type = on.array && Array.isArray(subject)? \"Array\" : \"Element\";\n\n\t\t\t\t\treturn $[Type].prototype[method].apply({subject: subject}, args);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}, 0);\n\n$.add($.Array.prototype, {element: false});\n$.add($.Element.prototype);\n$.add($.setProps);\n$.add($.classProps, {element: false, array: false});\n\n// Add native methods on $ and _\nvar dummy = document.createElement(\"_\");\n$.add($.extend({}, HTMLElement.prototype, function(method) {\n\treturn $.type(dummy[method]) === \"function\";\n}), null, true);\n\n\n})();\n\n(function($) {\n\"use strict\";\n\nif (!Bliss || Bliss.shy) {\n\treturn;\n}\n\nvar _ = Bliss.property;\n\n// Methods requiring Bliss Full\n$.add({\n\t// Clone elements, with events and data\n\tclone: function () {\n\t\tconsole.warn(\"$.clone() is deprecated and will be removed in a future version of Bliss.\");\n\t\tvar clone = this.cloneNode(true);\n\t\tvar descendants = $.$(\"*\", clone).concat(clone);\n\n\t\t$.$(\"*\", this).concat(this).forEach(function(element, i, arr) {\n\t\t\t$.events(descendants[i], element);\n\t\t\tdescendants[i]._.data = $.extend({}, element._.data);\n\t\t});\n\n\t\treturn clone;\n\t}\n}, {array: false});\n\n// Define the _ property on arrays and elements\n\nObject.defineProperty(Node.prototype, _, {\n\t// Written for IE compatability (see #49)\n\tget: function getter () {\n\t\tObject.defineProperty(Node.prototype, _, {\n\t\t\tget: undefined\n\t\t});\n\t\tObject.defineProperty(this, _, {\n\t\t\tvalue: new $.Element(this)\n\t\t});\n\t\tObject.defineProperty(Node.prototype, _, {\n\t\t\tget: getter\n\t\t});\n\t\treturn this[_];\n\t},\n\tconfigurable: true\n});\n\nObject.defineProperty(Array.prototype, _, {\n\tget: function () {\n\t\tObject.defineProperty(this, _, {\n\t\t\tvalue: new $.Array(this)\n\t\t});\n\n\t\treturn this[_];\n\t},\n\tconfigurable: true\n});\n\n// Hijack addEventListener and removeEventListener to store callbacks\n\nif (self.EventTarget && \"addEventListener\" in EventTarget.prototype) {\n\tEventTarget.prototype.addEventListener = function(type, callback, options) {\n\t\treturn $.bind(this, type, callback, options);\n\t};\n\n\tEventTarget.prototype.removeEventListener = function(type, callback, options) {\n\t\treturn $.unbind(this, type, callback, options);\n\t};\n}\n\n// Set $ and $$ convenience methods, if not taken\nself.$ = self.$ || $;\nself.$$ = self.$$ || $.$;\n\n})(Bliss);\n\n\n//# sourceURL=webpack:///../node_modules/blissfuljs/bliss.js?");

/***/ })

}]);